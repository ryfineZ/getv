import { BaseParser } from './base';
import type { VideoInfo, ParseResult, VideoFormat, Subtitle } from '../types';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

/**
 * 基于 yt-dlp 的通用解析器
 * 支持 1000+ 视频平台
 */
export class YtDlpParser extends BaseParser {
  readonly platform = 'other' as const;
  readonly name = 'yt-dlp';

  async parse(url: string): Promise<ParseResult> {
    try {
      // 使用 yt-dlp 获取视频信息
      const { stdout } = await execAsync(
        `python3 -m yt_dlp --dump-json --no-warnings "${url}"`,
        {
          maxBuffer: 10 * 1024 * 1024, // 10MB
          timeout: 30000, // 30s timeout
        }
      );

      const data = JSON.parse(stdout);

      // 提取格式
      const formats: VideoFormat[] = [];
      const seenQualities = new Set<string>();

      if (data.formats && Array.isArray(data.formats)) {
        for (const f of data.formats) {
          if (!f.url) continue;

          // 只保留有视频的格式
          if (f.vcodec === 'none' && f.acodec === 'none') continue;

          const quality = f.format_note || f.height ? `${f.height}p` : 'unknown';
          const key = `${quality}-${f.ext}`;

          // 去重
          if (seenQualities.has(key)) continue;
          seenQualities.add(key);

          formats.push(this.createFormat({
            id: f.format_id || `fmt-${Date.now()}`,
            quality,
            format: f.ext || 'mp4',
            size: f.filesize || f.filesize_approx,
            url: f.url,
            hasAudio: f.acodec !== 'none',
            hasVideo: f.vcodec !== 'none',
            bitrate: f.tbr || f.abr || f.vbr,
          }));
        }
      }

      // 如果没有格式，使用直接 URL
      if (formats.length === 0 && data.url) {
        formats.push(this.createFormat({
          id: 'default',
          quality: 'best',
          format: 'mp4',
          url: data.url,
          hasAudio: true,
          hasVideo: true,
        }));
      }

      // 按质量排序
      formats.sort((a, b) => {
        const qualityOrder = ['2160p', '1440p', '1080p', '720p', '480p', '360p', '240p', '144p'];
        const aIdx = qualityOrder.indexOf(a.quality);
        const bIdx = qualityOrder.indexOf(b.quality);
        return aIdx - bIdx;
      });

      // 提取字幕
      const subtitles: Subtitle[] = [];
      const subtitleSources = [
        { data: data.subtitles, isAuto: false },
        { data: data.automatic_captions, isAuto: true },
      ];

      for (const source of subtitleSources) {
        if (source.data && typeof source.data === 'object') {
          for (const [langCode, tracks] of Object.entries(source.data)) {
            if (!Array.isArray(tracks) || tracks.length === 0) continue;
            // 优先选择 vtt 格式，其次 srt
            const track = (tracks as Array<{ ext?: string; url?: string; name?: string }>).find(t => t.ext === 'vtt')
              || (tracks as Array<{ ext?: string; url?: string; name?: string }>).find(t => t.ext === 'srt')
              || (tracks as Array<{ ext?: string; url?: string; name?: string }>)[0];
            if (track?.url) {
              subtitles.push({
                lang: langCode,
                label: (track as { name?: string }).name || langCode,
                url: track.url,
                format: (track as { ext?: string }).ext || 'vtt',
                isAutoGenerated: source.isAuto,
              });
            }
          }
        }
      }

      return this.createSuccess({
        id: data.id || Date.now().toString(),
        platform: 'other',
        title: data.title || '未知标题',
        description: data.description,
        thumbnail: data.thumbnail || data.thumbnails?.[0]?.url || '',
        duration: data.duration || 0,
        durationText: this.formatDuration(data.duration || 0),
        author: data.uploader || data.channel || data.creator,
        authorAvatar: data.uploader_url,
        formats: formats.slice(0, 10),
        subtitles: subtitles.length > 0 ? subtitles : undefined,
        originalUrl: url,
        parsedAt: Date.now(),
      });
    } catch (error) {
      console.error('[YtDlp] Error:', error);

      const errorMessage = error instanceof Error ? error.message : '解析失败';

      if (errorMessage.includes('cookies')) {
        return this.createError('该视频需要登录才能访问');
      }
      if (errorMessage.includes('blocked')) {
        return this.createError('IP 被封禁，请稍后重试');
      }
      if (errorMessage.includes('not available')) {
        return this.createError('视频不可用或已删除');
      }

      return this.createError('解析失败，请检查链接是否正确');
    }
  }
}
